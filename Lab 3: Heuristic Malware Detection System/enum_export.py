import pefile
import sys

import os #for interacting with file systems
import collections #to count hashable objects


#validate argument as a correct folder path
if len(sys.argv) != 2:
        print("Please provide the folder path as an argument")
        sys.exit(1)

#extract the folder path from the command line arguments
folder_path = sys.argv[1]


#transverse each file in the specified folder recursively using os.walk
for root, dirs, files in os.walk(folder_path):
        for file in files:
                filePath = os.path.join(root, file)
                try:
                        #attempt to open file as PE
                        pe = pefile.PE(filePath)
                except pefile.PEFormatError:
                        #handle case when file is not PE
                        print(f"File {filePath} is not in PE format")
                        continue
                except OSError as e:
                        #handle errors reading file
                        print(f"Failed to read {filePath}: {e}")
                        continue

                if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                        addresses = [exp.address for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols if exp.address is not None]
                        #sort addresses to continually compare
                        addresses.sort()

                        # Check for three or more export functions have the same memory address
                        addressTotal = collections.Counter(addresses)
                        sameAddrViol = any(count >= 3 for count in addressTotal.values())

                        # Check for three or more export functions have the same memory offset
                        offsets = [addresses[i+1] - addresses[i] for i in range(len(addresses) - 1)]
                        offsetTotal = collections.Counter(offsets)
                        memoryDiffViol = any(count >= 2 for count in offsetTotal.values())

                        violationList = []
                        if sameAddrViol:
                                violationList.append("Rule 1")
                        if memoryDiffViol:
                                violationList.append("Rule 2")

                        if violationList:
                                print(f"Potential malware detected in {filePath}. Violates {' and '.join(violationList)}")
                        else:
                                print(f"NO potential malware detected in {filePath}.")
                else:
                        print(f"No export functions found in {filePath}.")
